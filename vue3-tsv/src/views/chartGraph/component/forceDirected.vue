<template>
  <div class="component-echart-graph">
    <VueEcharts
      class="chart"
      :option="chartOptions"
      ResizeObserver
      ref="chartRef"
      @mousedown="handleMouseDown"
      @mousemove="handleMouseMove"
      @mouseover="handleMouseUp"
      @mouseup="handleMouseUp"
    />
  </div>
</template>

<script setup lang="ts">
/* message */
import {
    defineEmits, useSlots, useAttrs, defineComponent,
    ref,
    onMounted,
    nextTick
 } from "vue";
import { VueEcharts } from 'vue3-echarts';
// import {data} from "./forceDirectedData";
import {cloneDeep}from "lodash"

const props = defineProps({}); // eslint-disable-line

const emit = defineEmits([]); // eslint-disable-line
const slots = useSlots(); // eslint-disable-line
const attrs = useAttrs(); // eslint-disable-line
defineComponent({
    VueEcharts
})

// https://echarts.apache.org/examples/data/asset/data/webkit-dep.json
const chartRef = ref<VueEcharts>();
const chartOptions = ref({
    grid:{
        left: '3%',
        right: '4%',
        bottom: '3%',
        top: '3%',
        containLabel: true
    },
    legend: {
        data: ['HTMLElement', 'WebGL', 'SVG', 'CSS', 'Other']
    },
    series: [
        {
            type: 'graph',
            layout: 'none',
            animation: false,
            symbolSize: 20,
            label: {
                position: 'right',
                formatter: '{b}'
            },
            draggable: true,
            roam: 'scale',
            force: {
                edgeLength: 5,
                repulsion: 20,
                gravity: 0.2
            },
            data:[],
            categories:[],
            edges:[],
            // data: webkitDep.nodes.map(function (node, idx) {
            //     node.id = idx;
            //     return node;
            // }),
            // categories: webkitDep.categories,
            // edges: webkitDep.links
        }
    ]
})


/**
 * A force directed graph layout implementation by liuchang on 2018/05/10.
 */
let CANVAS_WIDTH = 1000;
let CANVAS_HEIGHT = 1000;
let k;
let mNodeList: Array<Node> = [];
let mEdgeList: Array<Edge> = [];
let mDxMap: {
        [key: number]: number
    } = {};
let mDyMap: {
        [key: number]: number
    } = {};
let mNodeMap: {
        [key: string]: Node
    } = {};
let dragNode: Node= null

function forceDirectedInit() {
    //generate nodes and edges
    for (let i = 0; i < 20; i++) {
        mNodeList.push(new Node(i)); // 生成节点
    }

    for (let i = 0; i < 20; i++) {
        let edgeCount = Math.random() * 8 + 1; // 和最多8个元素相连
        for (let j = 0; j < edgeCount; j++) {
            let targetId = Math.floor(Math.random() * 20);
            let edge = new Edge(i, targetId);
            mEdgeList.push(edge); // 生成边
        }
    }
    if (mNodeList && mEdgeList) {
        k = Math.sqrt(CANVAS_WIDTH * CANVAS_HEIGHT / mNodeList.length); // 屏幕系数 单位元素所占面积的开方
    }
    for (let i = 0; i < mNodeList.length; i++) {
        let node = mNodeList[i];
        if (node) {
            mNodeMap[node.id] = node; // node kv map
        }
    }

    //随机生成坐标. Generate coordinates randomly.
    let initialX, initialY, initialSize = 40.0; // initialSize 随机范围
    for (let i in mNodeList) {
        initialX = CANVAS_WIDTH * .5; // 屏幕中心
        initialY = CANVAS_HEIGHT * .5; 
        mNodeList[i].x = initialX + initialSize * (Math.random() - .5);
        mNodeList[i].y = initialY + initialSize * (Math.random() - .5);
    }

    
    //console.log();
    
}

function forceDirectedUpdate(){
    
    calculateRepulsive(); // 遍历节点 两两斥力计算
    calculateTraction(); // 根据关系边计算引力
    updateCoordinates(); // 坐标赋值 边缘处理
    return cloneDeep(new Result(mNodeList, mEdgeList));
}

class Node{
    id: number;
    name: string;
    x: number;
    y: number;
   constructor (id: number) {
    this.id = id;
    this.name = 'name-'+id
    this.x = 22;
    this.y = null;
   }
}
class Edge{
    source: number;
    target: number;
    constructor(source = null, target = null) {
    this.source = source;
    this.target = target;
    }
}

/**
 * 计算两个Node的斥力产生的单位位移。
 * Calculate the displacement generated by the repulsive force between two nodes.*
 */
function calculateRepulsive() {
    let ejectFactor = 6;
    let distX, distY, dist;
    for (let i = 0; i < mNodeList.length; i++) {
        mDxMap[mNodeList[i].id] = 0.0;
        mDyMap[mNodeList[i].id] = 0.0;
        for (let j = 0; j < mNodeList.length; j++) {
            if(mNodeList[i].id === dragNode?.id){
                continue;
            }
            if (i !== j) {
                distX = mNodeList[i].x - mNodeList[j].x;
                distY = mNodeList[i].y - mNodeList[j].y;
                dist = Math.sqrt(distX * distX + distY * distY);
            }
            if (dist < 30) {
                ejectFactor = 5;
            }
            if (dist > 0 && dist < 250) {
                let id = mNodeList[i].id;
                mDxMap[id] = mDxMap[id] + distX / dist * k * k / dist * ejectFactor;
                mDyMap[id] = mDyMap[id] + distY / dist * k * k / dist * ejectFactor;
            }
        }
    }
}

/**
 * 计算Edge的引力对两端Node产生的引力。
 * Calculate the traction force generated by the edge acted on the two nodes of its two ends.
 */
function calculateTraction() {
    let condenseFactor = 3;
    let startNode, endNode;
    for (let e = 0; e < mEdgeList.length; e++) {
        let eStartID = mEdgeList[e].source;
        let eEndID = mEdgeList[e].target;
        startNode = mNodeMap[eStartID];
        endNode = mNodeMap[eEndID];
        if (!startNode) {
        console.log("Cannot find start node id: " + eStartID + ", please check it out.");
        return;
        }
        if (!endNode) {
        console.log("Cannot find end node id: " + eEndID + ", please check it out.");
        return;
        }
        let distX, distY, dist;
        distX = startNode.x - endNode.x;
        distY = startNode.y - endNode.y;
        dist = Math.sqrt(distX * distX + distY * distY);
        if(mNodeList[eStartID].id !== dragNode?.id){
            mDxMap[eStartID] = mDxMap[eStartID] - distX * dist / k * condenseFactor;
            mDyMap[eStartID] = mDyMap[eStartID] - distY * dist / k * condenseFactor;
        }
        if(mNodeList[eEndID].id !== dragNode?.id){
            mDxMap[eEndID] = mDxMap[eEndID] + distX * dist / k * condenseFactor;
            mDyMap[eEndID] = mDyMap[eEndID] + distY * dist / k * condenseFactor;
        }
    }
}

/**
 * 更新坐标。
 * update the coordinates.
 */
function updateCoordinates() {
    let maxt = 4, maxty = 3; //Additional coefficients.
    for (let v = 0; v < mNodeList.length; v++) {
        let node = mNodeList[v];
        let dx = Math.floor(mDxMap[node.id]);
        let dy = Math.floor(mDyMap[node.id]);

        if (dx < -maxt) dx = -maxt;
        if (dx > maxt) dx = maxt;
        if (dy < -maxty) dy = -maxty;
        if (dy > maxty) dy = maxty;
        node.x = node.x + dx >= CANVAS_WIDTH || node.x + dx <= 0 ? node.x - dx : node.x + dx;
        node.y = node.y + dy >= CANVAS_HEIGHT || node.y + dy <= 0 ? node.y - dy : node.y + dy;
    }
}

function Result(nodes: Array<Node>, links:Array<Edge>) {
    this.nodes = nodes;
    this.links = links;
}

let cnt = 0;
let i = 0
function grapthUpdate(){
    if(i++ % 40 == 0){

        let res = forceDirectedUpdate();

        const serie = chartOptions.value.series[0]
        serie.data = res.nodes
        serie.edges = res.links

        console.log('dragNode', JSON.stringify( serie.data.find(v=> v.id == (dragNode && dragNode.id))))
        chartRef.value.refreshOption()
    }
    if(/* cnt++ < 100 */ true){
        requestAnimationFrame(grapthUpdate);
    }
}
async function init(){
    forceDirectedInit()
    requestAnimationFrame(grapthUpdate)
}

onMounted(async ()=>{
    await nextTick();
    console.log('chartRef.value', chartRef.value)
    init()
})


function handleMouseDown(e){
    if(e.dataType == 'node'){
        console.log('handleMouseDown', e)
        dragNode = e.data
    }
}
function handleMouseMove(e){
    if(dragNode){
        dragNode.x = e.offsetX
        dragNode.y = e.offsetY
        console.log('handleMouseMove', e,dragNode)
    }
}
function handleMouseUp(e){
    if(dragNode && dragNode.id == e.data.id){
        console.log('handleMouseUp', e)
        dragNode = null
    }
}

</script>

<style lang="scss" scoped>
.component-echart-graph {
  width: 100%;
  height: 100%;
}
.chart {
  width: 100%;
  height: 100%;
}
</style>



